; There is no fxadds or fxsubs, because ADD and SUB are all you need.

:fxaddd
; Add YX to BA, leave overflow in O

ADD A, X
ADD B, O
SET C, O   ; see if the carry carried
ADD B, Y   ; if it did, this won't
BOR C, O   ; set O in either case
SET O, C
SET PC, POP

:fxsubd
; Subtract YX from BA, leave overflow in O

SUB A, X
ADD B, O   ; if this doesn't carry, then we borrowed from 0
SET C, O
SUB C, 1   ; C is now 0xFFFF if we borrowed from 0, 0x0000 otherwise
SUB B, Y
BOR C, O
SET O, C
SET PC, POP

:fxmuls
; Multiply A by B, leave overflow in O
; AA.AA * BB.BB = OOCC.DDxx
; CC.DD is the answer we want, XX gets thrown away, OO is the overflow

MUL A, B   ; A = DDXX, O = OOCC
SET X, O   ; X = OOCC
SHR A, 8   ; A = 00DD
SHL X, 8   ; X = CC00, O = 00OO
BOR A, X   ; A = CCDD
SET PC, POP

:fxmuld
; Multiply BA by XC, leave overflow in O
;           BBBB AAAA
;         * XXXX CCCC
; -------------------
;           CCCC*AAAA
;      CCCC*BBBB
;      XXXX*AAAA
; XXXX*BBBB
; -----------------
; OOOO BBBB AAAA xxxx
SET C, X   ; set XC to YX to work with trig functions
SET X, Y   ;     without a complete rewrite. -VEA
SET I, A   ; we can't lose A yet
MUL I, X   ; X*A
SET C, O   ; save overflow of X*A for second column
MUL A, Y   ; Y*A (duh), and begin accumulating in A
SET Z, O   ; save overflow of Y*A for third column, begin accumulating in Z
ADD A, C   ; accumulate overflow of X*A, we can now reuse C
ADD Z, O   ; potential carry from the second column
           ; the above cannot produce a propagating carry
MUL X, B   ; X*B (duh)
ADD Z, O   ; accumulate overflow of X*B for third column
SET C, O   ; which can produce a carry
ADD A, X   ; accumulate X*B
ADD Z, O   ; this can carry again, and we accumulate the third column in Z
ADD C, O   ; potential carry from third column
MUL B, Y   ; Y*B, begin accumulating in B
ADD C, O   ; add overflow of Y*B to fourth column
           ; fourth column cannot overflow
ADD B, Z   ; accumulate the rest of the third column
ADD C, O   ; potential carry
SET O, C   ; set O

SET PC, POP

:fxdivs
; Divide A by B (UNSIGNED)
; AA.AA / BB.BB = OOCC.DDxx
DIV A, B   ; A = OOCC, O = DDxx
SET X, O   ; X = DDxx
SHR X, 8   ; X = 00DD
SHL A, 8   ; A = CC00, O = 00OO
BOR A, X   ; A = CCDD
SET PC, POP

:fxdivd
; pass in B.A/X.C, return B.A with overflow C
; remainder of integer portion divide in JI
; ViEtArmis/David Timm Apr. 09, 2012

SET PUSH, 0 ; low part of quotient
SET Y, 32768
SET Z, 0
SET I, 0
SET J, 0

; performs bit operations on higher word
:div_loop1
IFE Y, 0
    SET PC, div_part2

SHL J, 1
SHL I, 1
XOR J, O

SET PUSH, Y
AND Y, B
IFG Y, 0
    BOR I, 1
SET Y, POP

IFG J, X
    SET PC, div_doit1
IFE J, X
    SET PC, div_chksml1
SET PC, div_next1

:div_chksml1
IFG I, C
    SET PC, div_doit1
IFE I, C
    SET PC, div_doit1
SET PC, div_next1

:div_doit1
SUB I, C
ADD J, O
SUB J, X

BOR Z, Y

:div_next1
SHR Y, 1

SET PC, div_loop1

; performs bit operations on lower word
:div_part2
SET Y, 32768
:div_loop2
IFE Y, 0
    SET PC, div_done

SHL J, 1
SHL I, 1
XOR J, O

SET PUSH, Y
AND Y, A
IFG Y, 0
    BOR I, 1
SET Y, POP

IFG J, X
    SET PC, div_doit2
IFE J, X
    SET PC, div_chksml2
SET PC, div_next2

:div_chksml2
IFG I, C
    SET PC, div_doit2
IFE I, C
    SET PC, div_doit2
SET PC, div_next2

:div_doit2
SUB I, C
ADD J, O
SUB J, X

SET O, POP
BOR O, Y
SET PUSH, O

:div_next2
SHR Y, 1

SET PC, div_loop2

:div_done
SET C, Z
SET B, POP
DIV I, X
SET Z, 65535
DIV Z, X
MUL Z, J
ADD I, Z
SET A, I

SET PC, POP

:fxexpd
; pass in B.A^C, return B.A
; ViEtArmis/David Timm Apr. 09, 2012
SET Y, C
SET PUSH, B
SET PUSH, A
SET PUSH, Y
SET X, B
SET C, A

:exp_loop
IFE Y, 1
    SET PC, exp_done
JSR fxmuld
SET POP, Y
SUB Y, 1
SET C, POP
SET X, POP
SET PUSH, X
SET PUSH, C
SET PUSH, Y
SET PC, exp_loop

:exp_done
SET POP, POP
SET PC, POP

:fxsind
; input B.A, return B.A = sin(B.A)
; Z==1 if value is negative.
; ViEtArmis/David Timm Apr. 11, 2012
set push, 0
set push, a
set push, b
jsr pi_d
jsr cmpd
ife z, 1
    add pc, 2
set pc, sin_cont

; normalize to under pi, tracking if
; this will make it negative
jsr fxdivd
set b, a
set a, 0
set j, pop
set i, pop
set z, pop
set z, 1
and z, b
set push, z
set push, i
set push, j
jsr pi_d
jsr fxmuld
set x, b
set c, a
set b, pop
set a, pop
sub a, c
add b, o
sub b, x
set push, a
set push, b

:sin_cont
set c, 3
jsr fxexpd
set x, 6
set c, 0
jsr fxdivd
set x, a
set b, pop
set a, pop
set i, a
set j, b
sub a, c
add b, o
sub b, x
set push, a
set push, b

set a, i
set b, j
set push, i
set push, j
set c, 5
jsr fxexpd
set x, 120
set c, 0
jsr fxdivd
set x, a
set j, pop
set i, pop
set b, pop
set a, pop
add a, c
add b, o
add b, x

set push, a
set push, b
set push, i
set push, j
set a, i
set b, j
set c, 7
jsr fxexpd
set x, 5040
set c, 0
jsr fxdivd
set x, a
set j, pop
set i, pop
set b, pop
set a, pop
sub a, c
add b, o
sub b, x

set z, pop
set pc, pop


:fxcosd
; input B.A, return B.A = cos(B.A)
; Z==1 if value is negative.
; ViEtArmis/David Timm Apr. 11, 2012
jsr pid2_d
add a, c
add b, o
add b, x

jsr fxsind

set pc, pop


:fxtand
; input B.A, return B.A = tan(B.A)
; Z==1 if value is negative.
; ViEtArmis/David Timm Apr. 11, 2012

set push, a
set push, b

jsr fxcosd

set i, a
set j, b
set b, pop
set a, pop
set push, z
set push, i
set push, j

jsr fxsind

set x, pop
set c, pop
add z, pop
and z, 1

div a, c
set b, o

set pc, pop


:cmpd
; input BA cmp XC, returns Z is 0xFFFF if BA<XC,
; 0x0000 if BA==XC, and 0x0001 if BA>XC
; ViEtArmis/David Timm Apr. 10, 2012
IFG B, X
    SET Z, 1
IFG X, B
    SET Z, 65535
IFE B, X
    JSR cmp_check
SET PC, POP

:cmp_check
IFG A, C
    SET Z, 1
IFG C, A
    SET Z, 65535
IFE A, C
    SET Z, 0

SET PC, POP


; pi in 16.16 fixed point
:pi_d
set c, 9279
set x, 3
set pc, pop

; 2*pi in 16.16 fixed point
:pix2_d
set c, 18558
set x, 6
set pc, pop

; pi/2 in 16.16 fixed point
:pid2_d
set c, 37408
set x, 1
set pc, pop
